// Generated by CoffeeScript 1.6.3
var CodeMerger, UError, dfb, isEqualCode, isLikeCode, l, toAST, toCode, _, _B;

_ = (_B = require('uberscore'))._;

l = new _B.Logger('uRequire/codeUtils/CodeMerger');

UError = require('../utils/UError');

toCode = require("./toCode");

toAST = require("./toAST");

isLikeCode = require("./isLikeCode");

isEqualCode = require("./isEqualCode");

dfb = new _B.DeepDefaultsBlender;

CodeMerger = (function() {
  CodeMerger.options = {
    uniqueDeclarations: true
  };

  function CodeMerger(options) {
    this.options = options != null ? options : CodeMerger.options;
    if (options !== CodeMerger.options) {
      dfb.blend(this.options, CodeMerger.options);
    }
    this.declarations || (this.declarations = []);
    this.statements || (this.statements = []);
  }

  CodeMerger.prototype.reset = function() {
    this.declarations = [];
    return this.statements = [];
  };

  CodeMerger.prototype.addbodyNode = function(node) {
    var decl, dublicateDecl, _i, _len, _ref;
    if (node.type === 'VariableDeclaration') {
      _ref = node.declarations;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        decl = _ref[_i];
        if (!_.any(this.declarations, function(fd) {
          return _.isEqual(decl, fd);
        })) {
          if (dublicateDecl = _.find(this.declarations, function(fd) {
            return isLikeCode({
              type: decl.type,
              id: decl.id
            }, fd);
          })) {
            if (this.options.uniqueDeclarations) {
              throw new UError("Duplicate var declaration while merging code:\n\n" + (toCode(decl)) + "\n\nis a duplicate of\n\n" + (toCode(dublicateDecl)));
            } else {
              l.debug(90, "Replacing declaration of '" + decl.id.name + "'");
              dublicateDecl.init = decl.init;
            }
          } else {
            l.debug(90, "Adding declaration of '" + decl.id.name + "'");
            this.declarations.push(decl);
          }
        }
      }
    } else {
      if (!_.any(this.statements, function(fd) {
        return _.isEqual(node, fd);
      })) {
        this.statements.push(node);
      }
    }
    return null;
  };

  /*
    add `code`, which can be:
      * String: a string of parsable Javascript code
      * Array: of body nodes
      * Object: a single node OR a program
  */


  CodeMerger.prototype.add = function(code) {
    var node, _i, _len, _ref, _ref1, _results;
    if (!_.isEmpty(code)) {
      _ref1 = ((_ref = toAST(code, 'Program')) != null ? _ref.body : void 0) || [];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        node = _ref1[_i];
        _results.push(this.addbodyNode(node));
      }
      return _results;
    }
  };

  Object.defineProperties(CodeMerger.prototype, {
    'AST': {
      get: function() {
        if (_.isEmpty(this.declarations)) {
          return this.statements;
        } else {
          return [
            {
              type: 'VariableDeclaration',
              declarations: this.declarations,
              kind: 'var'
            }
          ].concat(this.statements);
        }
      }
    },
    'code': {
      get: function() {
        return toCode(this.AST);
      }
    }
  });

  return CodeMerger;

})();

module.exports = CodeMerger;
