// Generated by CoffeeScript 1.6.3
var AlmondOptimizationTemplate, Build, Bundle, BundleBase, BundleFile, CodeMerger, DependenciesReporter, Dependency, FileResource, MasterDefaultsConfig, Module, ResourceConverterError, TextResource, UError, debugLevelSkipTempDeletion, fs, globExpand, isFileInSpecs, l, toCode, upath, _, _B,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = (_B = require('uberscore'))._;

l = new _B.Logger('uRequire/process/Bundle');

_.mixin((require('underscore.string')).exports());

fs = require('fs');

globExpand = require('glob-expand');

upath = require('../paths/upath');

MasterDefaultsConfig = require('../config/MasterDefaultsConfig');

AlmondOptimizationTemplate = require('../templates/AlmondOptimizationTemplate');

Dependency = require('../fileResources/Dependency');

DependenciesReporter = require('./../utils/DependenciesReporter');

UError = require('../utils/UError');

ResourceConverterError = require('../utils/ResourceConverterError');

BundleFile = require('./../fileResources/BundleFile');

FileResource = require('./../fileResources/FileResource');

TextResource = require('./../fileResources/TextResource');

Module = require('./../fileResources/Module');

Build = require('./Build');

BundleBase = require('./BundleBase');

CodeMerger = require('../codeUtils/CodeMerger');

toCode = require('../codeUtils/toCode');

isFileInSpecs = require('../config/isFileInSpecs');

debugLevelSkipTempDeletion = 50;

/*
  @todo: doc it!
*/


Bundle = (function(_super) {
  var isCalcPropDepsVars, isCalcPropFiles;

  __extends(Bundle, _super);

  function Bundle(bundleCfg) {
    Bundle.__super__.constructor.apply(this, arguments);
    _.extend(this, bundleCfg);
    this.files = {};
  }

  Bundle.prototype.inspect = function() {
    return l.prettify({
      name: this.name,
      main: this.main,
      files: this.files
    });
  };

  Bundle.calcProperties = {
    filenames: function() {
      var _this = this;
      if (_.isEmpty(this.files)) {
        return _.filter(globExpand({
          cwd: this.path,
          filter: 'isFile'
        }, '**/*'), function(f) {
          return isFileInSpecs(f, _this.filez);
        });
      } else {
        return _.keys(this.files);
      }
    },
    dstFilenames: function() {
      return _.map(this.files, function(f) {
        return f.dstFilename;
      });
    },
    fileResources: function() {
      return _.pick(this.files, function(f) {
        return f instanceof FileResource;
      });
    },
    textResources: function() {
      return _.pick(this.files, function(f) {
        return f instanceof TextResource;
      });
    },
    modules: function() {
      return _.pick(this.files, function(f) {
        return f instanceof Module;
      });
    },
    copyBundleFiles: function() {
      var _this = this;
      if (_.isEmpty(this.copy)) {
        return {};
      } else {
        return _.pick(this.files, function(f, filename) {
          return !(f instanceof FileResource) && (isFileInSpecs(filename, _this.copy));
        });
      }
    },
    localNonNode_depsVars: function() {
      return this.inferEmptyDepVars(this.getDepsVars(function(dep) {
        return dep.isLocal && !dep.isNode;
      }), 'Gathering @localNonNode_depsVars (bundle`s local dependencies) & infering empty depVars');
    },
    nodeOnly_depsVars: function() {
      l.debug(80, "Gathering 'node'-only dependencies");
      return this.getDepsVars(function(dep) {
        return dep.isNode;
      });
    },
    exportsBundle_depsVars: function() {
      return this.inferEmptyDepVars(_.clone(this.dependencies.exports.bundle, true), "Gathering @exportsBundle_depsVars & infering empty depVars for `dependencies.exports.bundle`");
    },
    errorFiles: function() {
      return _.pick(this.files, function(f) {
        return f.hasErrors;
      });
    }
  };

  isCalcPropDepsVars = function(p) {
    return _(p).endsWith('depsVars');
  };

  isCalcPropFiles = function(p) {
    return p === 'filenames' || p === 'dstFilenames' || p === 'fileResources' || p === 'textResources' || p === 'modules' || p === 'copyFiles' || p === 'errorFiles';
  };

  Object.defineProperties(Bundle.prototype, {
    doneOK: {
      get: function() {
        return _.isEmpty(this.errorFiles) && (this.errorsCount === 0);
      }
    }
  });

  /*
  Gathers dependencies & corresponding variables/parameters (they bind with),
  througout this bundle (all modules).
  
  @param {Function} depFltr a filter, passed a Dependency instance
  
  @return {dependencies.depsVars} `dependency: ['var1', 'var2']` eg
    {
        'lodash': ['_']
        'jquery': ["$", "jQuery"]
        'models/PersonModel': ['persons', 'personsModel']
    }
  */


  Bundle.prototype.getDepsVars = function(depFltr) {
    var dep, depsVars, dv, k, mod, v, vars, _i, _len, _ref, _ref1;
    if (depFltr == null) {
      depFltr = function() {
        return true;
      };
    }
    depsVars = {};
    _ref = this.modules;
    for (k in _ref) {
      mod = _ref[k];
      _ref1 = mod.getDepsVars(depFltr);
      for (dep in _ref1) {
        vars = _ref1[dep];
        dv = (depsVars[dep] || (depsVars[dep] = []));
        for (_i = 0, _len = vars.length; _i < _len; _i++) {
          v = vars[_i];
          if (__indexOf.call(dv, v) < 0) {
            dv.push(v);
          }
        }
      }
    }
    return depsVars;
  };

  Bundle.prototype.inferEmptyDepVars = function(depVars, whyMessage) {
    var aVar, depName, depVarsPath, dependenciesDepsVars, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    if (depVars == null) {
      depVars = {};
    }
    if (!_.isEmpty(depVars) && l.deb(70)) {
      l.debug('inferEmptyDepVars:', whyMessage);
      l.debug(80, 'inferEmptyDepVars(depVars = ', depVars);
    }
    for (depName in depVars) {
      if (_.isEmpty((depVars[depName] || (depVars[depName] = [])))) {
        if (l.deb(80)) {
          l.deb("inferEmptyDepVars : Dependency '" + depName + "' has no corresponding parameters/variable names to bind with.");
        }
        _ref = this.getDepsVars(function(dep) {
          return dep.name({
            relative: 'bundle'
          }) === depName;
        })[depName] || [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          aVar = _ref[_i];
          if (__indexOf.call(depVars[depName], aVar) < 0) {
            depVars[depName].push(aVar);
          }
        }
        if (l.deb(80)) {
          l.deb("inferEmptyDepVars: Dependency '" + depName + "', inferred varNames from bundle's Modules: ", depVars[depName]);
        }
        if (_.isEmpty(depVars[depName])) {
          _ref1 = _.map(['depsVars', '_knownDepsVars', 'exports.bundle', 'exports.root'], function(v) {
            return 'dependencies.' + v;
          });
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            depVarsPath = _ref1[_j];
            dependenciesDepsVars = _B.getp(this, depVarsPath, {
              separator: '.'
            });
            if ((!_.isEmpty(dependenciesDepsVars[depName])) && (depVars[depName] !== dependenciesDepsVars[depName])) {
              l.warn("" + whyMessage + ":\n", "Picking var bindings for `" + depName + "` from `@" + depVarsPath + "`", dependenciesDepsVars[depName]);
              _ref2 = dependenciesDepsVars[depName];
              for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                aVar = _ref2[_k];
                if (__indexOf.call(depVars[depName], aVar) < 0) {
                  depVars[depName].push(aVar);
                }
              }
            }
          }
        }
      }
      if (_.isEmpty(depVars[depName])) {
        this.handleError(new UError("No variable names can be identified for injected or local or node-only dependency '" + depName + "'.\n\nThese variable names are used to :\n  - inject the dependency into each module\n    OR\n  - grab the dependency from the `window` object, when running as <script> via the 'combined' template.\n\nRemedy:\n\nIf you are injecting eg. at uRequire's config 'bundle.dependencies.exports.bundle', you 'd better declare it as:\n  ```\n    dependencies: exports: bundle: {\n      '" + depName + "': 'VARIABLE(S)_IT_BINDS_WITH',\n      ...\n      jquery: ['$', 'jQuery'],  // Array of known bindings\n      backbone: 'Backbone'      // A String will also do\n    }\n  ```\ninstead of the simpler\n  ```\n    dependencies: exports: bundle: [ '" + depName + "', ...., 'jquery', 'backbone' ]\n  ```\n\nAlternativelly, pick one medicine :\n  - define at least one module that has this dependency + variable binding (either as AMD or commonJs) and uRequire will infer it!\n\n  - declare it in the above format, but in `bundle.dependencies.varNames` and uRequre will pick it from there!\n\n  - use an `rjs.shim`, and uRequire will pick it from there (@todo: NOT IMPLEMENTED YET!)"));
        l.warn(this.dstFilenames);
      }
    }
    l.debug(80, 'returning inferred depVars =', depVars);
    return depVars;
  };

  /*
    Processes each filename, either as array of filenames (eg instructed by `watcher`) or all @filenames
  
    If a filename is new, create a new BundleFile (or more interestingly a TextResource or Module)
  
    In any case, refresh() each one, either new or existing. Internally BundleFile notes `hasChanged`. 
  
    @param []<String> with filenames to process.
      @default ALL files from filesystem (property @filenames)
  
    @return null
  */


  Bundle.prototype.loadOrRefreshResources = function(filenames) {
    var bf, dstFilename, err, filename, isNew, lastResourcesWithClazz, lastSrcMain, matchedConverters, resConv, resourceClass, sameDstFile, _i, _j, _len, _len1, _ref, _ref1,
      _this = this;
    if (filenames == null) {
      filenames = this.filenames;
    }
    if (l.deb(30)) {
      l.debug(" \n\n#####################################################################\nloadOrRefreshResources: filenames.length = " + filenames.length + "\n#####################################################################");
    }
    for (_i = 0, _len = filenames.length; _i < _len; _i++) {
      filename = filenames[_i];
      isNew = false;
      if (!(bf = this.files[filename])) {
        isNew = true;
        lastSrcMain = void 0;
        matchedConverters = [];
        dstFilename = filename;
        _ref = this.resources;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          resConv = _ref[_j];
          if (isFileInSpecs((resConv.isMatchSrcFilename ? filename : dstFilename), resConv.filez)) {
            if (_.isFunction(resConv.convFilename)) {
              dstFilename = resConv.convFilename(dstFilename, filename);
            }
            if (resConv.srcMain) {
              lastSrcMain = resConv.srcMain;
            }
            matchedConverters.push(resConv);
          }
        }
        lastResourcesWithClazz = _.filter(matchedConverters, function(conv) {
          return conv.clazz;
        });
        resourceClass = ((_ref1 = _.last(lastResourcesWithClazz)) != null ? _ref1.clazz : void 0) || BundleFile;
        if (l.deb(80)) {
          l.debug("New *" + resourceClass.name + "*: '" + filename + "'");
        }
        bf = this.files[filename] = new resourceClass({
          bundle: this,
          srcFilename: filename,
          converters: matchedConverters,
          srcMain: lastSrcMain
        });
      }
      if (bf.srcMain && this.build.current[bf.srcMain]) {
        l.debug(60, "Skipping refresh/conversion(s) of '" + bf.srcFilename + "', as part of converted @srcMain='" + bf.srcMain + "'.");
        continue;
      }
      if (l.deb(80)) {
        l.debug("Refreshing " + bf.constructor.name + ": '" + filename + "'");
      }
      try {
        if (bf.refresh()) {
          this.build.addChangedBundleFile(filename, bf);
        }
      } catch (_error) {
        err = _error;
        this.build.addChangedBundleFile(filename, bf);
        if (bf.srcExists) {
          bf.reset();
          bf.hasErrors = true;
          if (err instanceof ResourceConverterError) {
            this.handleError(err);
          } else {
            this.handleError(new UError("Unknown error while loading/refreshing/processing '" + filename + "'.", {
              nested: err
            }));
          }
        } else {
          if (this.mainModule === this.files[filename]) {
            delete this.mainModule;
          }
          delete this.files[filename];
          l.verbose("Missing file " + bf.srcFilepath + " - deleting dstFilename = '" + bf.dstFilename + "'");
          if (bf.dstExists && bf.hasErrors !== 'duplicate') {
            bf.dstDelete();
          }
          bf.hasErrors = false;
        }
      }
      if (bf.srcMain) {
        this.build.current[bf.srcMain] = true;
      }
      if (isNew && !bf.srcMain) {
        if (sameDstFile = _.find(this.files, function(f) {
          return (f.dstFilename === bf.dstFilename) && (f !== bf);
        })) {
          bf.hasErrors = 'duplicate';
          this.handleError(new UError("Same dstFilename='" + sameDstFile.dstFilename + "' for new resource '" + bf.srcFilename + "' & '" + sameDstFile.srcFilename + "'.", {
            nested: err
          }));
        }
      }
    }
    this.cleanProps((!_.isEmpty(this.build.changedFiles) ? isCalcPropFiles : void 0), (!_.isEmpty(this.build.changedModules) ? isCalcPropDepsVars : void 0));
    l.debug("### finished loadOrRefreshResources: " + (_.size(this.build.changedFiles)) + " changed files.");
    return null;
  };

  /*
    Our only true entry point
    It builds / converts all resources that are passed as filenames
    It 'temporarilly' sets a @build instance, with which it 'guides' the build.
  */


  Bundle.prototype.buildChangedResources = function(build, filenames) {
    var bundleFilenames, diff, file, fn, isPartialBuild, _ref,
      _this = this;
    this.build = build;
    if (filenames == null) {
      filenames = this.filenames;
    }
    this.errorsCount = 0;
    isPartialBuild = filenames !== this.filenames;
    if (l.deb(20)) {
      l.debug(" \n\n#####################################################################\nbuildChangedResources: build #" + build.count + "\nbundle.name = " + this.name + ", bundle.main = " + this.main + "\nfilenames.length = " + filenames.length + " " + (!isPartialBuild ? '(full build)' : '') + "\n#####################################################################");
    }
    this.reporter = new DependenciesReporter();
    if (isPartialBuild) {
      if (!this.build.hasFullBuild) {
        l.warn("Forcing a full build (this was a partial build, without a previous full build).");
        _ref = this.files;
        for (fn in _ref) {
          file = _ref[fn];
          file.reset();
        }
        if (this.build.template.name === 'combined') {
          this.build.deleteCombinedTemp();
          l.warn("Partial/watch build with 'combined' template wont DELETE '" + this.build.template._combinedFileTemp + "' - when you quit 'watch'-ing, delete it your self!");
        }
        this.buildChangedResources(this.build, this.filenames);
        return;
      }
      bundleFilenames = _.filter(filenames, function(f) {
        return isFileInSpecs(f, _this.filez) && f[0] !== '.';
      });
      if (diff = filenames.length - bundleFilenames.length) {
        l.verbose("Ignored " + diff + " non-`bundle.filez`");
        filenames = bundleFilenames;
      }
    } else {
      this.build.doClean();
    }
    if (!filenames.length) {
      l.verbose("No files to process.");
    } else {
      this.loadOrRefreshResources(filenames);
      if (!_.isEmpty(this.build.changedFiles)) {
        this.convertChangedModules();
        this.concatMainModuleBanner();
        this.saveChangedResources();
        this.copyChangedBundleFiles();
        if (this.doneOK && !isPartialBuild && ((this.build.template.name !== 'combined') || this.build.watch)) {
          this.build.hasFullBuild = true;
        }
        if (this.build.template.name === 'combined') {
          return this.combine();
        }
      } else {
        l.verbose("No bundle files *really* changed.");
      }
    }
    this.build.report(this);
    return this.build.done(this.doneOK);
  };

  Bundle.prototype.convertChangedModules = function() {
    var err, fn, mod, _ref;
    if (!_.isEmpty(this.build.changedModules)) {
      if (l.deb(30)) {
        l.debug(" \n\n#####################################################################\nConverting changed modules with template '" + this.build.template.name + "'\n#####################################################################");
      }
      _ref = this.modules;
      for (fn in _ref) {
        mod = _ref[fn];
        if (mod.hasChanged) {
          if (mod.hasErrors) {
            l.debug(30, "Not converting '" + mod.srcFilename + "' cause it has errors.");
          } else {
            try {
              mod.adjust(this.build);
              mod.runResourceConverters(function(rc) {
                return rc.isBeforeTemplate && !rc.isAfterTemplate;
              });
              mod.convertWithTemplate(this.build);
              mod.runResourceConverters(function(rc) {
                return rc.isAfterTemplate && !rc.isBeforeTemplate;
              });
              mod.optimize(this.build);
              mod.runResourceConverters(function(rc) {
                return rc.isAfterOptimize;
              });
              mod.addReportData();
            } catch (_error) {
              err = _error;
              mod.reset();
              mod.hasErrors = true;
              this.handleError(new UError("Error at `convertChangedModules()`", {
                nested: err
              }));
            }
          }
        }
      }
    }
    return null;
  };

  Bundle.prototype.concatMainModuleBanner = function() {
    if (!_.isEmpty(this.build.changedModules)) {
      if (this.build.template.banner && (this.build.template.name !== 'combined')) {
        if (this.mainModule || this.inferMainModule()) {
          if (this.mainModule.hasChanged) {
            l.debug(40, "Concating `bundle.template.banner` to `@bundle.main` file = `" + this.mainModule.dstFilename + "`");
            this.mainModule.converted = this.build.template.banner + '\n' + this.mainModule.converted;
          }
        } else {
          l.warn("Can't concat `build.template.banner` - no @mainModule - tried `bundle.main`, `bundle.name`, 'index', 'main'.");
        }
      }
      return null;
    }
  };

  Bundle.prototype.saveChangedResources = function() {
    var err, fn, res, _ref;
    if (!_.isEmpty(this.build.changedResources)) {
      if (l.deb(30)) {
        l.debug(" \n\n#####################################################################\nSaving changed resource files that have a `converted` String\n#####################################################################");
      }
      _ref = this.fileResources;
      for (fn in _ref) {
        res = _ref[fn];
        if (!res.hasChanged) {
          continue;
        }
        if (res.hasErrors) {
          l.deb(40, "Not saving with errors: '" + res.dstFilename + "' (srcFilename = '" + res.srcFilename + "').");
        } else {
          if (res.converted && _.isString(res.converted)) {
            try {
              if (_.isFunction(this.build.out)) {
                this.build.out(res.dstFilename, res.converted);
              } else {
                res.save();
              }
            } catch (_error) {
              err = _error;
              res.hasErrors = true;
              this.handleError(new UError("Error while " + (_.isFunction(this.build.out) ? '`build.out()`-ing' : '`save()`-ing') + " resource '" + res.dstFilename + "'.", {
                nested: err
              }));
            }
          } else {
            l.debug(80, "Not saving non-String: '" + res.srcFilename + "' as '" + res.dstFilename + "'.");
          }
        }
        res.hasChanged = false;
      }
    }
    return null;
  };

  Bundle.prototype.copyChangedBundleFiles = function() {
    var bundleFile, copiedCount, err, fn, skippedCount, _ref;
    if (!_.isEmpty(this.copyBundleFiles)) {
      if (l.deb(30)) {
        l.debug(" \n\n#####################################################################\nCopying " + (_.size(this.copyBundleFiles)) + " non-resources files (that match `bundle.copy`)\"\n#####################################################################");
      }
      copiedCount = skippedCount = 0;
      _ref = this.copyBundleFiles;
      for (fn in _ref) {
        bundleFile = _ref[fn];
        if (bundleFile.hasChanged) {
          try {
            if (bundleFile.copy()) {
              copiedCount++;
            } else {
              skippedCount++;
            }
            bundleFile.hasChanged = false;
          } catch (_error) {
            err = _error;
            bundleFile.hasErrors = true;
            this.handleError(err);
          }
        }
      }
    }
    return this.build._copied = [copiedCount, skippedCount];
  };

  Bundle.prototype.inferMainModule = function() {
    var mainCand, mainMod, _i, _len, _ref,
      _this = this;
    if (this.main) {
      mainMod = _.find(this.modules, function(m) {
        return m.path === _this.main;
      });
    } else {
      _ref = [this.name, 'index', 'main'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        mainCand = _ref[_i];
        if (!(mainCand)) {
          continue;
        }
        mainMod = _.find(this.modules, function(m) {
          return m.path === mainCand;
        });
        if (mainMod) {
          break;
        }
      }
    }
    return this.mainModule = mainMod;
  };

  Bundle.prototype.requirejs = require('requirejs');

  /*
  */


  Bundle.prototype.combine = function() {
    var combErr, combinedTemplate, depfilename, genCode, rjsConfig, rjsStartDate, _ref,
      _this = this;
    if (_.isEmpty(this.build.changedModules)) {
      l.verbose("Not executing *'combined' template optimizing with r.js*: no @modules changed in build #" + this.build.count + ".");
      this.build.report(this);
      this.build.done(this.doneOK);
      return;
    } else {
      if (_.size(this.build.errorFiles)) {
        if ((_.size(this.build.changedModules) - _.size(this.build.errorFiles)) <= 0) {
          l.er("Not executing *'combined' template optimizing with r.js*: no changed modules without error in build #" + this.build.count + ".");
          this.build.report(this);
          this.build.done(this.doneOK);
          return;
        } else {
          l.warn("Executing *'combined' template optimizing with r.js*: although there are errors in build #" + this.build.count + " (using last valid saved modules).");
        }
      }
    }
    if (l.deb(30)) {
      l.debug(" \n\n#####################################################################\n'combined' template: optimizing with r.js & almond\n#####################################################################");
    }
    if (this.mainModule || this.inferMainModule()) {
      if (!this.main) {
        this.main = this.mainModule.path;
        l.warn("`combine` template note: `bundle.main`, your *entry-point module* was missing from `bundle` config.\nIt's defaulting to " + (this.main === this.name ? '`bundle.name` = ' : '') + "'" + this.main + "', as uRequire found an existing '" + this.path + "/" + this.mainModule.srcFilename + "' module in your path.");
      }
    } else {
      combErr = "`bundle.main` should be your *entry-point module*, kicking off the bundle.\nIt is required for `combined` template execution.";
      if (!this.main) {
        this.handleError(new UError("Missing `bundle.main` from config.\n" + combErr + "\nTried to infer it from `bundle.name` = '" + this.name + "', or as ['index', 'main'], but no suitable module was found in bundle."));
      } else {
        this.handleError(new UError("Module `bundle.main` = '" + this.main + "' not found in bundle.\n" + combErr + "\nNOT trying to infer from `bundle.name` = '" + this.name + "', nor as ['index', 'main'] - `bundle.main` is respected."));
      }
    }
    combinedTemplate = new AlmondOptimizationTemplate(this);
    _ref = combinedTemplate.dependencyFiles;
    for (depfilename in _ref) {
      genCode = _ref[depfilename];
      TextResource.save(upath.join(this.build.template._combinedFileTemp, depfilename + '.js'), genCode);
    }
    this.copyAlmondJs();
    this.copyWebMapDeps();
    rjsConfig = {
      paths: _.extend(combinedTemplate.paths, this.getRequireJSConfig().paths),
      wrap: combinedTemplate.wrap,
      baseUrl: this.build.template._combinedFileTemp,
      include: [this.main],
      deps: _.keys(this.nodeOnly_depsVars),
      useStrict: this.build.useStrict || _.isUndefined(this.build.useStrict) ? true : false,
      name: 'almond',
      out: function(text) {
        text = (_this.build.template.banner ? _this.build.template.banner + '\n' : '') + combinedTemplate.uRequireBanner + ("// Combined template optimized with RequireJS/r.js v" + _this.requirejs.version + " & almond.") + '\n' + text;
        return FileResource.save(_this.build.template.combinedFile, text);
      }
    };
    if (rjsConfig.optimize = this.build.optimize) {
      rjsConfig[this.build.optimize] = this.build[this.build.optimize];
    } else {
      rjsConfig.optimize = "none";
    }
    if (l.deb(90)) {
      rjsConfig.logLevel = 0;
    }
    if (!_.isEmpty(this.build.rjs)) {
      _.defaults(rjsConfig, _.clone(this.build.rjs, true));
    }
    if (l.deb(20)) {
      l.debug("requirejs.optimize (v" + this.requirejs.version + ") with uRequire's 'build.js' = \n", _.omit(rjsConfig, ['wrap']));
    }
    rjsStartDate = new Date();
    return this.requirejs.optimize(rjsConfig, function(buildResponse) {
      if (l.deb(20)) {
        l.debug('@requirejs.optimize rjsConfig, (buildResponse)-> = ', buildResponse);
      }
      if (fs.existsSync(_this.build.template.combinedFile)) {
        l.ok("Combined file '" + _this.build.template.combinedFile + "' written successfully for build #" + _this.build.count + ", rjs.optimize took " + ((new Date() - rjsStartDate) / 1000) + "secs .");
        if (!_.isEmpty(_this.localNonNode_depsVars)) {
          if ((!_this.build.watch) || l.deb(50)) {
            l.verbose("\nDependencies: make sure the following `local` depsVars bindinds:\n", combinedTemplate.localDepsVars, "\n\nare available when combined script '" + _this.build.template.combinedFile + "' is running on:\n  a) nodejs: they should exist as a local `nodes_modules`.\n  b) Web/AMD: they should be declared as `rjs.paths` (and/or `rjs.shim`)\n  c) Web/Script: the binded variables (eg '_' or '$')\n     must be a globally loaded (i.e `window.$`)\n     BEFORE loading '" + _this.build.template.combinedFile + "'\n");
          }
        }
        if (!(l.deb(debugLevelSkipTempDeletion) || _this.build.watch)) {
          _this.build.deleteCombinedTemp();
        } else {
          l.debug(10, "NOT Deleting temporary directory '" + _this.build.template._combinedFileTemp + "', due to build.watch || debugLevel >= " + debugLevelSkipTempDeletion + ".");
        }
        _this.build.report(_this);
        return _this.build.done(_this.doneOK);
      } else {
        l.er("Combined file '" + _this.build.template.combinedFile + "' NOT written - this should not have happened, requirejs reported success.\nCheck requirejs's build response:\n", buildResponse);
        _this.build.report(_this);
        return _this.build.done(false);
      }
    }, function(errorResponse) {
      _this.build.report(_this);
      l.er('@requirejs.optimize errorResponse: ', errorResponse, "\n\nCombined file '" + _this.build.template.combinedFile + "' NOT written.\"\n\n  Some remedy:\n\n   a) Is your *bundle.main = '" + _this.main + "'* or *bundle.name = '" + _this.name + "'* properly defined ?\n      - 'main' should refer to your 'entry' module, that requires all other modules - if not defined, it defaults to 'name'.\n      - 'name' is what 'main' defaults to, if its a module.\n\n   b) Perhaps you have a missing dependcency ?\n      r.js doesn't like this at all, but it wont tell you unless logLevel is set to error/trace, which then halts execution.\n\n   c) Re-run uRequire with debugLevel >=90, to enable r.js's logLevel:0 (trace).\n      *Note this prevents uRequire from finishing properly / printing this message!*\n\n   Note that you can check the AMD-ish files used in temporary directory '" + _this.build.template._combinedFileTemp + "'.\n\n   More remedy on the way... till then, you can try running r.js optimizer your self, based on the following build.js: \u001b[0m\n", rjsConfig);
      return _this.build.done(false);
    });
  };

  Bundle.prototype.getRequireJSConfig = function() {
    var _ref;
    if (!_.isEmpty((_ref = this.build) != null ? _ref.rjs : void 0)) {
      return this.build.rjs;
    } else {
      return {};
    }
  };

  Object.defineProperties(Bundle.prototype, {
    mergedPreDefineIIFECode: {
      get: function() {
        var cm, m, mod, _ref;
        if (l.deb(80)) {
          l.debug("Merging pre-Define IIFE code from all " + (_.keys(this.modules).length) + " @modules");
        }
        cm = new CodeMerger;
        _ref = this.modules;
        for (m in _ref) {
          mod = _ref[m];
          cm.add(mod.AST_preDefineIIFENodes);
        }
        return toCode(cm.AST, {
          format: {
            indent: {
              base: 1
            }
          }
        });
      }
    },
    mergedCode: {
      get: function() {
        var cm, m, mod, _ref;
        if (l.deb(80)) {
          l.debug("Merging mergedCode code from all " + (_.keys(this.modules).length) + " @modules");
        }
        cm = new CodeMerger;
        _ref = this.modules;
        for (m in _ref) {
          mod = _ref[m];
          cm.add(mod.mergedCode);
        }
        return toCode(cm.AST, {
          format: {
            indent: {
              base: 1
            }
          }
        });
      }
    }
  });

  Bundle.prototype.copyAlmondJs = function() {
    var err;
    try {
      return BundleFile.copy("" + __dirname + "/../../../node_modules/almond/almond.js", upath.join(this.build.template._combinedFileTemp, 'almond.js'));
    } catch (_error) {
      err = _error;
      return this.build.handleError(new UError("uRequire: error copying almond.js from uRequire's installation node_modules - is it installed ?\nTried: '" + __dirname + "/../../../node_modules/almond/almond.js'", {
        nested: err
      }));
    }
  };

  /*
   Copy all bundle's webMap dependencies to build.template._combinedFileTemp
   @todo: use path.join
   @todo: should copy dep.plugin & dep.resourceName separatelly
  */


  Bundle.prototype.copyWebMapDeps = function() {
    var depName, webRootDeps, _i, _len;
    webRootDeps = _.keys(this.getDepsVars(function(dep) {
      return dep.isWebRootMap;
    }));
    if (!_.isEmpty(webRootDeps)) {
      l.verbose("Copying webRoot deps :\n", webRootDeps);
      for (_i = 0, _len = webRootDeps.length; _i < _len; _i++) {
        depName = webRootDeps[_i];
        l.er("NOT IMPLEMENTED: copyWebMapDeps " + this.webRoot + depName + ", " + this.build.template._combinedFileTemp + depName);
      }
    }
    return null;
  };

  Bundle.prototype.printError = function(error) {
    l.er(error.message || 'no error.message', '\n error.nested = ', error.nested || "no error.nested");
    return l.deb(110, '\n error.stack = \n', error.stack);
  };

  Bundle.prototype.handleError = function(error) {
    if (error == null) {
      error = new UError("Undefined or null error!");
    }
    this.errorsCount++;
    if (error.quit) {
      throw error;
    } else {
      if (this.build) {
        if (this.build["continue"] || this.build.watch) {
          this.printError(error);
          l.warn("Continuing despite of error due to `build.continue` || `build.watch`");
        } else {
          error.quit = true;
          throw error;
        }
      } else {
        this.printError(error);
        l.warn("Continuing despite of error, cause we have not one build (i.e we might have many!)");
      }
    }
    return null;
  };

  return Bundle;

})(BundleBase);

module.exports = Bundle;

_.extend(module.exports.prototype, {
  l: l,
  _: _,
  _B: _B
});
