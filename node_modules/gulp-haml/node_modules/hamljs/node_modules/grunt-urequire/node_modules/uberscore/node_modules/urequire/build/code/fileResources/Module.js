// Generated by CoffeeScript 1.6.3
var Dependency, Module, ModuleGeneratorTemplates, TextResource, UError, fs, isEqualCode, isLikeCode, isTrueOrFileInSpecs, l, replaceCode, toAST, toCode, upath, util, _, _B, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = (_B = require('uberscore'))._;

l = new _B.Logger('uRequire/Module');

_.mixin((require('underscore.string')).exports());

fs = require('fs');

util = require('util');

upath = require('../paths/upath');

ModuleGeneratorTemplates = require('../templates/ModuleGeneratorTemplates');

TextResource = require('./TextResource');

Dependency = require("./Dependency");

UError = require('../utils/UError');

isTrueOrFileInSpecs = require('../config/isTrueOrFileInSpecs');

isLikeCode = require("../codeUtils/isLikeCode");

isEqualCode = require("../codeUtils/isEqualCode");

replaceCode = require("../codeUtils/replaceCode");

toAST = require("../codeUtils/toAST");

toCode = require("../codeUtils/toCode");

Module = (function(_super) {
  var bof, _fn, _i, _len, _ref1;

  __extends(Module, _super);

  function Module() {
    this.requireFinder = __bind(this.requireFinder, this);
    _ref = Module.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  Object.defineProperties(Module.prototype, {
    dstPath: {
      get: function() {
        var _ref1, _ref2;
        if ((_ref1 = this.bundle) != null ? _ref1.build.template._combinedFileTemp : void 0) {
          return this.bundle.build.template._combinedFileTemp;
        } else {
          if ((_ref2 = this.bundle) != null ? _ref2.build.dstPath : void 0) {
            return this.bundle.build.dstPath;
          } else {
            return '';
          }
        }
      }
    }
  });

  _ref1 = ['useStrict', 'bare', 'globalWindow', 'runtimeInfo', 'noRootExports', 'allNodeRequires', 'dummyParams', 'scanAllow', 'injectExportsModule'];
  _fn = function(bof) {
    return Object.defineProperty(Module.prototype, 'is' + _.capitalize(bof), {
      get: function() {
        var _ref2, _ref3;
        return isTrueOrFileInSpecs((_ref2 = this.bundle) != null ? (_ref3 = _ref2.build) != null ? _ref3[bof] : void 0 : void 0, this.path);
      }
    });
  };
  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
    bof = _ref1[_i];
    _fn(bof);
  }

  /*
    Check if `super` in TextResource has spotted changes and thus has a possibly changed @converted (javascript code)
    & call `@adjust()` if so.
  
    It does not actually convert to any template - the bundle building does that
  
    But the module info needs to provide dependencies information (eg to inject Dependencies etc)
  */


  Module.prototype.refresh = function() {
    if (!Module.__super__.refresh.apply(this, arguments)) {
      return false;
    } else {
      if (this.sourceCodeJs !== this.converted) {
        this.sourceCodeJs = this.converted;
        this.extract();
        this.prepare();
        return this.hasChanged = true;
      } else {
        if (l.deb(90)) {
          l.debug("No changes in compiled sourceCodeJs of module '" + this.srcFilename + "' ");
        }
        return this.hasChanged = false;
      }
    }
  };

  Module.prototype.reset = function() {
    Module.__super__.reset.apply(this, arguments);
    delete this.sourceCodeJs;
    return this.resetModuleInfo();
  };

  Module.prototype.resetModuleInfo = function() {
    var dv, _j, _len1, _ref2;
    this.flags = {};
    _ref2 = this.keys_extractedDepsAndVarsArrays;
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      dv = _ref2[_j];
      this[dv] = [];
    }
    delete this.defineArrayDeps;
    return delete this.parameters;
  };

  Module.prototype.AST_data = ['AST_top', 'AST_body', 'AST_factoryBody', 'AST_preDefineIIFENodes'];

  Module.prototype.keys_extractedDepsAndVarsArrays = ['ext_defineArrayDeps', 'ext_defineFactoryParams', 'ext_requireDeps', 'ext_requireVars', 'ext_asyncRequireDeps', 'ext_asyncFactoryParams'];

  Module.prototype.keys_resolvedDependencies = ['defineArrayDeps', 'nodeDeps'];

  Module.prototype.info = function() {
    var info, p, _j, _len1, _ref2,
      _this = this;
    info = {};
    _ref2 = _.flatten([this.keys_extractedDepsAndVarsArrays, this.keys_resolvedDependencies, ['flags', 'name', 'kind', 'path', 'factoryBody', 'preDefineIIFEBody', 'parameters']]);
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      p = _ref2[_j];
      if (!_.isEmpty(this[p])) {
        if (_.isArray(this[p])) {
          info[p] = _.map(this[p], function(x) {
            if (__indexOf.call(_this.keys_resolvedDependencies, p) >= 0) {
              return x.name();
            } else {
              return x.toString();
            }
          });
        } else {
          info[p] = this[p];
        }
      }
    }
    return info;
  };

  Module.prototype.readArrayDepsAndVars = function(arrayAst, arrayDeps, paramsAst, factoryParams) {
    var arrayDep, astArrayDep, excParamIdx, idx, param, _j, _k, _len1, _ref2, _ref3, _ref4, _ref5, _ref6;
    _ref2 = arrayAst.elements;
    for (idx = _j = 0, _len1 = _ref2.length; _j < _len1; idx = ++_j) {
      astArrayDep = _ref2[idx];
      param = (_ref3 = paramsAst[idx]) != null ? _ref3.name : void 0;
      if (_B.isLike({
        type: 'Literal'
      }, astArrayDep)) {
        arrayDep = new Dependency(astArrayDep.value, this, {
          AST_requireLiterals: [astArrayDep]
        });
      } else {
        arrayDep = new Dependency(this.toCode(astArrayDep), this, {
          untrusted: true,
          AST_requireUntrustedDep: [astArrayDep]
        });
      }
      if (arrayDep) {
        arrayDeps.push(arrayDep);
      }
      if (param) {
        factoryParams.push(param);
      }
    }
    for (excParamIdx = _k = _ref4 = arrayAst.elements.length, _ref5 = paramsAst.length - 1; _k <= _ref5; excParamIdx = _k += 1) {
      factoryParams.push((_ref6 = paramsAst[excParamIdx]) != null ? _ref6.name : void 0);
    }
    return this;
  };

  Module.prototype.requireFinder = function(prop, src, dst, blender) {
    var args, requireDep, requireVar;
    if (_B.isLike({
      type: "CallExpression",
      callee: {
        type: "Identifier",
        name: "require"
      }
    }, src[prop])) {
      if (_B.isLike({
        "arguments": [
          {
            type: 'Literal'
          }
        ]
      }, src[prop])) {
        requireDep = new Dependency(src[prop]["arguments"][0].value, this, {
          AST_requireLiterals: [src[prop]["arguments"][0]]
        });
      } else {
        if (_B.isLike([
          {
            type: 'ArrayExpression'
          }, {
            type: 'FunctionExpression'
          }
        ], src[prop]["arguments"])) {
          args = src[prop]["arguments"];
          this.readArrayDepsAndVars(args[0], (this.ext_asyncRequireDeps || (this.ext_asyncRequireDeps = [])), args[1].params, (this.ext_asyncFactoryParams || (this.ext_asyncFactoryParams = [])));
        } else {
          requireDep = new Dependency(this.toCode(src[prop]["arguments"][0]), this, {
            untrusted: true
          });
        }
      }
      if (_B.isLike({
        type: 'AssignmentExpression',
        left: {
          type: 'Identifier'
        }
      }, src) || _B.isLike({
        type: 'VariableDeclarator',
        id: {
          type: 'Identifier'
        }
      }, src)) {
        requireVar = _B.isLike({
          type: 'AssignmentExpression'
        }, src) ? src.left.name : src.id.name;
        if (src[prop]["arguments"].length > 1) {
          l.warn("Wrong require() signature in " + (this.toCode(src[prop])) + "\nUse the proper AMD `require([dep1, dep2], function(dep1, dep2){...})` for the asnychronous AMD require.");
        }
      }
      if (requireDep) {
        if (requireVar) {
          (this.ext_requireVars || (this.ext_requireVars = [])).push(requireVar);
          (this.ext_requireDeps || (this.ext_requireDeps = [])).splice(this.ext_requireVars.length - 1, 0, requireDep);
        } else {
          (this.ext_requireDeps || (this.ext_requireDeps = [])).push(requireDep);
        }
      }
    }
    return null;
  };

  Module.prototype.extract = function() {
    var AMDSignature, args, bodyNode, define, defines, err, i, idx, _j, _k, _len1, _ref2, _ref3;
    if (l.deb(70)) {
      l.debug("@extract for '" + this.srcFilename + "'");
    }
    this.resetModuleInfo();
    try {
      this.AST_top = toAST(this.sourceCodeJs);
    } catch (_error) {
      err = _error;
      throw new UError("Error while parsing top Module's javascript.", {
        nested: err
      });
    }
    if (isLikeCode('(function(){}).call()', this.AST_top.body) || isLikeCode('(function(){}).apply()', this.AST_top.body)) {
      this.AST_body = this.AST_top.body[0].expression.callee.object.body.body;
      this.AST_preDefineIIFENodes = [];
    } else {
      if (isLikeCode('(function(){})()', this.AST_top.body)) {
        this.AST_body = this.AST_top.body[0].expression.callee.body.body;
        this.AST_preDefineIIFENodes = [];
      } else {
        this.AST_body = this.AST_top.body;
      }
    }
    defines = [];
    _ref2 = this.AST_body;
    for (idx = _j = 0, _len1 = _ref2.length; _j < _len1; idx = ++_j) {
      bodyNode = _ref2[idx];
      if (bodyNode.expression && isLikeCode('define()', bodyNode)) {
        defines.push(bodyNode.expression);
        if (defines.length > 1) {
          throw new UError("Each AMD file shoule have one (top-level or IIFE) define call - found " + defines.length + " `define` calls");
        }
      } else {
        if (isLikeCode('({urequire:{}})', bodyNode)) {
          this.flags = (eval(this.toCode(bodyNode))).urequire;
        } else {
          if (!(isLikeCode('var define;', bodyNode) || isLikeCode('if(typeof define!=="function"){define=require("amdefine")(module);}', bodyNode) || isLikeCode('if(typeof define!=="function"){var define=require("amdefine")(module);}', bodyNode)) && !isLikeCode(';', bodyNode) && (defines.length === 0) && this.AST_preDefineIIFENodes) {
            this.AST_preDefineIIFENodes.push(bodyNode);
          }
        }
      }
    }
    if (defines.length === 1) {
      define = defines[0];
      args = define["arguments"];
      AMDSignature = ['Literal', 'ArrayExpression', 'FunctionExpression'];
      for (i = _k = 0, _ref3 = args.length - 1; 0 <= _ref3 ? _k <= _ref3 : _k >= _ref3; i = 0 <= _ref3 ? ++_k : --_k) {
        if (args[i].type !== AMDSignature[i + (3 - args.length)]) {
          throw new UError("Invalid AMD define() signature with " + args.length + " args: got a '" + args[i].type + "' as arg " + i + ", expected a '" + AMDSignature[i + (3 - args.length)] + "'.");
        }
      }
      this.kind = 'AMD';
      if (args.length === 3) {
        this.name = args[0].value;
      }
      if (args.length >= 2) {
        this.readArrayDepsAndVars(args[args.length - 2], this.ext_defineArrayDeps, args[args.length - 1].params, this.ext_defineFactoryParams);
      } else {
        this.ext_defineFactoryParams = _.map(args[args.length - 1].params, 'name');
      }
      this.AST_factoryBody = args[args.length - 1].body;
    } else {
      this.kind = 'nodejs';
      this.AST_factoryBody = _.isEmpty(this.AST_preDefineIIFENodes) ? this.AST_body : this.AST_preDefineIIFENodes;
      delete this.AST_preDefineIIFENodes;
    }
    _B.traverse(this.AST_factoryBody, this.requireFinder);
    if (l.deb(90)) {
      l.debug("'" + this.srcFilename + "' extracted module .info():\n", _.omit(this.info(), ['factoryBody', 'preDefineIIFEBody']));
    }
    return this;
  };

  Module.prototype.prepare = function() {
    var ar1, ar2, dep, lenDiff, pi, _j, _ref2;
    if (l.deb(70)) {
      l.debug("@prepare for '" + this.srcFilename + "'\n");
    }
    this.parameters = this.ext_defineFactoryParams.slice(0, +(this.ext_defineArrayDeps.length - 1) + 1 || 9e9);
    if (this.isDummyParams) {
      if ((lenDiff = this.ext_defineArrayDeps.length - this.parameters.length) > 0) {
        for (pi = _j = 1; 1 <= lenDiff ? _j <= lenDiff : _j >= lenDiff; pi = 1 <= lenDiff ? ++_j : --_j) {
          this.parameters.push("___dummy___param__" + pi);
        }
      }
    }
    this.defineArrayDeps = (function() {
      var _k, _len1, _ref2, _results;
      _ref2 = this.ext_defineArrayDeps;
      _results = [];
      for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
        dep = _ref2[_k];
        _results.push(dep.clone());
      }
      return _results;
    }).call(this);
    if (ar1 = (this.parameters[0] === 'require') | (ar2 = (_ref2 = this.defineArrayDeps[0]) != null ? typeof _ref2.isEqual === "function" ? _ref2.isEqual('require') : void 0 : void 0)) {
      if (ar1 && (ar2 || this.defineArrayDeps[0] === void 0)) {
        this.parameters.shift();
        this.defineArrayDeps.shift();
      } else {
        throw new UError(("Module '" + this.path + "':") + (ar1 ? "1st define factory argument is 'require', but 1st dependency is '" + this.defineArrayDeps[0] + "'" : "1st dependency is 'require', but 1st define factory argument is '" + this.parameters[0] + "'"));
      }
    }
    return this;
  };

  /*
  Produce final template information:
  
  - bundleRelative deps like `require('path/dep')` in factory, are replaced with their fileRelative counterpart
  
  - injecting dependencies?.exports?.bundle
  
  - add @ext_requireDeps to @defineArrayDeps
  @todo: decouple from build, use calculated (cached) properties, populated at convertWithTemplate(@build) step
  */


  Module.prototype.adjust = function(build) {
    var addToArrayDependencies, newDep, oldDep, oldDeps, reqDep, rootExports, rt, _base, _j, _k, _l, _len1, _len2, _len3, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,
      _this = this;
    this.build = build;
    if (l.deb(70)) {
      l.debug("\n@adjust for '" + this.srcFilename + "'");
    }
    if (((_ref2 = this.build) != null ? (_ref3 = _ref2.template) != null ? _ref3.name : void 0 : void 0) !== 'combined') {
      this.injectDeps((_ref4 = this.bundle) != null ? (_ref5 = _ref4.dependencies) != null ? (_ref6 = _ref5.exports) != null ? _ref6.bundle : void 0 : void 0 : void 0);
    }
    if (this.flags.rootExports) {
      this.flags.rootExports = _B.arrayize(this.flags.rootExports);
    }
    if (rootExports = (_ref7 = this.bundle) != null ? (_ref8 = _ref7.dependencies) != null ? (_ref9 = _ref8.exports) != null ? (_ref10 = _ref9.root) != null ? _ref10[this.path] : void 0 : void 0 : void 0 : void 0) {
      _ref11 = _B.arrayize(rootExports);
      for (_j = 0, _len1 = _ref11.length; _j < _len1; _j++) {
        rt = _ref11[_j];
        ((_base = this.flags).rootExports || (_base.rootExports = [])).push(rt);
      }
      this.flags.noConflict = true;
    }
    this.webRootMap = ((_ref12 = this.bundle) != null ? _ref12.webRootMap : void 0) || '.';
    addToArrayDependencies = function(reqDep) {
      var foundDeps, rl, _k, _len2, _ref13, _results;
      if (!reqDep.isNode) {
        foundDeps = _.filter(_this.defineArrayDeps, function(dep) {
          return dep.isEqual(reqDep);
        });
        if (_.isEmpty(foundDeps)) {
          reqDep = reqDep.clone();
          return _this.defineArrayDeps.push(reqDep);
        } else {
          _ref13 = reqDep.AST_requireLiterals || [];
          _results = [];
          for (_k = 0, _len2 = _ref13.length; _k < _len2; _k++) {
            rl = _ref13[_k];
            _results.push(_.last(foundDeps).AST_requireLiterals.push(rl));
          }
          return _results;
        }
      }
    };
    if (!(_.isEmpty(this.defineArrayDeps) && this.isScanAllow && !this.flags.rootExports)) {
      _ref13 = this.ext_requireDeps;
      for (_k = 0, _len2 = _ref13.length; _k < _len2; _k++) {
        reqDep = _ref13[_k];
        addToArrayDependencies(reqDep);
      }
    }
    this.updateRequireLiteralASTs();
    _ref16 = ((_ref14 = this.bundle) != null ? (_ref15 = _ref14.dependencies) != null ? _ref15.replace : void 0 : void 0) || {};
    for (newDep in _ref16) {
      oldDeps = _ref16[newDep];
      for (_l = 0, _len3 = oldDeps.length; _l < _len3; _l++) {
        oldDep = oldDeps[_l];
        this.replaceDep(oldDep, newDep, {
          relative: 'bundle'
        });
      }
    }
    return this;
  };

  Module.prototype.updateRequireLiteralASTs = function() {
    var dep, _j, _len1, _ref2, _results;
    _ref2 = _.flatten([this.defineArrayDeps, this.ext_asyncRequireDeps]);
    _results = [];
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      dep = _ref2[_j];
      if (dep && !dep.untrusted) {
        _results.push(dep.updateAST());
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Module.prototype.injectDeps = function(depVars) {
    var dep, depName, dependenciesBindingsBlender, varName, varNames, _j, _len1, _ref2;
    if (l.deb(40)) {
      if (!_.isEmpty(depVars)) {
        l.debug("" + this.path + ": injecting dependencies: ", depVars);
      }
    }
    dependenciesBindingsBlender = require('../config/blendConfigs').dependenciesBindingsBlender;
    if (_.isEmpty(depVars = dependenciesBindingsBlender.blend(depVars))) {
      return;
    }
    if ((_ref2 = this.bundle) != null) {
      if (typeof _ref2.inferEmptyDepVars === "function") {
        _ref2.inferEmptyDepVars(depVars, "Infering empty depVars from injectDeps for '" + this.path + "'");
      }
    }
    for (depName in depVars) {
      varNames = depVars[depName];
      dep = new Dependency(depName, this);
      if (!dep.isEqual(this.path)) {
        for (_j = 0, _len1 = varNames.length; _j < _len1; _j++) {
          varName = varNames[_j];
          if (!(__indexOf.call(this.parameters, varName) >= 0)) {
            this.defineArrayDeps.splice(this.parameters.length, 0, dep);
            this.parameters.push(varName);
            if (l.deb(70)) {
              l.debug("" + this.path + ": injected dependency '" + depName + "' as parameter '" + varName + "'");
            }
          } else {
            l.warn("" + this.path + ": NOT injecting dependency '" + depName + "' as parameter '" + varName + "' cause it already exists.");
          }
        }
      } else {
        if (l.deb(50)) {
          l.debug("" + this.path + ": NOT injecting dependency '" + depName + "' on self'");
        }
      }
    }
    return null;
  };

  /*
  Replaces one or more Dependencies with another dependency on the Module (not the whole Bundle).
  
  It makes the replacements on
  
     * All Dependency instances in `@defineArrayDeps` array (which is also where @nodeDeps are derived)
  
     * All AST Literals in code, in deps array ['literal',...] or require('literal') calls,
       **always leaving the fileRelative replaceDep string **
  
  @param matchDep {String|RegExp|Function|Dependency} The dependency/ies to match,
       @see Dependency::isMatch about dep matching in general
  
       When a partial search is used for matching (noted with `|` at end of dep, for example `'../../lib|'`),
       then a partial replacement (i.e translation) is also performed:
       All deps that pass `_(dep).startsWith('../../lib')` will get only their '../../lib' path replaced with newDep, instead of a whole replacement.
       Hence `mod.replaceDep '../../some2/external/lib|', '../other/wow/lib/'` will do the obvious, translate the first part all mactching deps, i.e `'../../some2/external/lib/DEPENDENCY'` will become `'../other/wow/lib/DEPENDENCY'`.
  
       @see options below for matching & replacing in `relative:'file'` (default) or `relative:'bundle'`
  
  @param replaceDep {Dependency|String|Undefined} The dependency to replace the old with.
    * If `replaceDep` is empty, it removes all `matchDep`s from @defineArrayDeps
      (BUT NOT FROM THE AST @todo: why not - it can be costly but optional?)
    * if its a partial matchDep, then its only the matched part that will be replaced
  
    properly copy & spec of all its properties, plugin etc.
  
  @param options: {relative, plugin, ext} Whether to have these considered
  
    relative: @todo: explain
  */


  Module.prototype.replaceDep = function(matchDep, newDep, options) {
    var debugHead, dep, depIdx, depName, err, isMatch, rai, removeArrayIdxs, updDep, _j, _k, _len1, _ref2;
    if (options == null) {
      options = {};
    }
    if (l.deb(70)) {
      l.deb(debugHead = "Module.replaceDep " + (newDep ? 'REPLACING' : ' DELETING') + ": " + (util.inspect(options)) + " " + (util.inspect(matchDep)) + ", " + (util.inspect(newDep)));
    }
    if (_.isString(matchDep)) {
      matchDep = new Dependency(matchDep, this);
    }
    if (matchDep instanceof Dependency) {
      if ((!options.relative) && (!matchDep.isRelative)) {
        options.relative = 'bundle';
      }
    }
    if (newDep) {
      if (!(newDep instanceof Dependency)) {
        if (_.isString(newDep)) {
          newDep = new Dependency(newDep, this);
        } else {
          if (!_.isFunction(newDep)) {
            l.er(err = "" + debugHead + " Wrong new dependency type '" + newDep + "' in module " + this.path + " - should be String|Dependency|Undefined.");
            throw new UError(err);
          }
        }
      }
    }
    removeArrayIdxs = [];
    _ref2 = this.defineArrayDeps || [];
    for (depIdx = _j = 0, _len1 = _ref2.length; _j < _len1; depIdx = ++_j) {
      dep = _ref2[depIdx];
      depName = dep.name(options);
      if (isMatch = (_.isFunction(matchDep) ? matchDep(depName, dep, options) : dep.isMatch(matchDep, options))) {
        if (!newDep) {
          l.debug(90, "mark depIdx for lazy removal '" + depIdx + "'");
          removeArrayIdxs.push(depIdx);
        } else {
          if (matchDep !== newDep) {
            updDep = _.isFunction(newDep) ? newDep(depName, dep) : newDep;
            if (_.isString(updDep)) {
              updDep = new Dependency(updDep, this);
            }
            if (updDep) {
              if (!(updDep instanceof Dependency)) {
                l.er(err = "Wrong newDep dependency type '" + matchDep + "' in module " + this.path + " - should be String|Function|Dependency.");
                throw new UError(err);
              } else {
                dep.update(updDep, matchDep, options);
              }
            } else {
              l.deb(90, "mark idx for lazy removal, returned from Function newDep '" + depIdx + "'");
              removeArrayIdxs.push(depIdx);
            }
          }
        }
      }
    }
    for (_k = removeArrayIdxs.length - 1; _k >= 0; _k += -1) {
      rai = removeArrayIdxs[_k];
      if (l.deb(80)) {
        l.deb("delete dependency '" + this.defineArrayDeps[rai] + "'");
      }
      this.defineArrayDeps.splice(rai, 1);
      this.parameters.splice(rai, 1);
    }
    return null;
  };

  /*
  Returns all deps in this module along with their corresponding parameters (variable names)
  @param {Function} depFltr optional callback filtering dependency, called with dep (defaults to all-true fltr)
  @return {Object}
      {
        jquery: ['$', 'jQuery']
        lodash: ['_']
        'models/person': ['pm']
      }
  */


  Module.prototype.getDepsVars = function(depFltr) {
    var bundleRelativeDep, dep, depVarArrays, depsArrayName, dv, idx, varNames, varsArrayName, _j, _len1, _ref2, _ref3;
    if (depFltr == null) {
      depFltr = function() {
        return true;
      };
    }
    varNames = {};
    depVarArrays = {
      'defineArrayDeps': 'parameters',
      'ext_requireDeps': 'ext_requireVars',
      'ext_asyncRequireDeps': 'ext_asyncFactoryParams'
    };
    for (depsArrayName in depVarArrays) {
      varsArrayName = depVarArrays[depsArrayName];
      _ref2 = this[depsArrayName] || [];
      for (idx = _j = 0, _len1 = _ref2.length; _j < _len1; idx = ++_j) {
        dep = _ref2[idx];
        if (!(depFltr(dep))) {
          continue;
        }
        bundleRelativeDep = dep.name({
          relative: 'bundle'
        });
        dv = (varNames[bundleRelativeDep] || (varNames[bundleRelativeDep] = []));
        if (this[varsArrayName][idx] && !(_ref3 = this[varsArrayName][idx], __indexOf.call(dv, _ref3) >= 0)) {
          dv.push(this[varsArrayName][idx]);
        }
      }
    }
    return varNames;
  };

  Module.prototype.replaceCode = function(matchCode, replCode) {
    return replaceCode(this.AST_factoryBody, matchCode, replCode);
  };

  Module.prototype.addReportData = function() {
    var dep, _j, _len1, _ref2, _ref3, _ref4, _results;
    _ref2 = _.flatten([
      this.defineArrayDeps, this.ext_asyncRequireDeps, _.filter(this.ext_requireDeps, function(dep) {
        return dep.isNode;
      })
    ]);
    _results = [];
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      dep = _ref2[_j];
      if ((_ref3 = dep.type) !== 'bundle' && _ref3 !== 'system') {
        _results.push((_ref4 = this.bundle) != null ? _ref4.reporter.addReportData(_B.okv(dep.type, dep.name({
          relative: 'bundle'
        })), this.path) : void 0);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Module.prototype.convertWithTemplate = function(build) {
    this.build = build;
    l.verbose("Converting '" + this.path + "' with template = '" + this.build.template.name + "'");
    if (l.deb(60)) {
      l.debug("'" + this.path + "' adjusted module.info() = \n", _.pick(this.info(), _.flatten([this.keys_resolvedDependencies, 'parameters', 'kind', 'name', 'flags'])));
    }
    this.moduleTemplate || (this.moduleTemplate = new ModuleGeneratorTemplates(this));
    return this.converted = this.moduleTemplate[this.build.template.name]();
  };

  Module.prototype.optimize = function(build) {
    var options;
    this.build = build;
    if (this.build.template.name !== 'combined') {
      if (this.build.optimize) {
        if (this.build.optimize === 'uglify2') {
          l.verbose("Optimizing '" + this.path + "' with UglifyJS2...");
          this.UglifyJS2 || (this.UglifyJS2 = require('uglify-js'));
          (options = this.build.uglify2 || {}).fromString = true;
          this.converted = (this.UglifyJS2.minify(this.converted, options)).code;
        } else {
          l.warn("Not using `build.optimize` with '" + this.build.optimize + "' - only 'uglify2' works for Modules.");
        }
      }
    }
    return this.converted;
  };

  Object.defineProperties(Module.prototype, {
    nodeDeps: {
      get: function() {
        var _ref2, _ref3;
        if (this.isAllNodeRequires) {
          return this.defineArrayDeps;
        } else {
          return ((_ref2 = this.defineArrayDeps) != null ? _ref2.slice(0, +((((_ref3 = this.parameters) != null ? _ref3.length : void 0) || 1) - 1) + 1 || 9e9) : void 0) || [];
        }
      }
    },
    path: {
      get: function() {
        if (this.srcFilename) {
          return upath.trimExt(this.srcFilename);
        }
      }
    },
    factoryBody: {
      get: function() {
        var fb;
        this.updateRequireLiteralASTs();
        fb = this.toCode(this.AST_factoryBody);
        if (this.kind === 'AMD') {
          fb = fb.slice(1, +(fb.length - 2) + 1 || 9e9).trim();
        }
        return fb;
      }
    },
    'preDefineIIFEBody': {
      get: function() {
        this.updateRequireLiteralASTs();
        if (this.AST_preDefineIIFENodes) {
          return this.toCode(this.AST_preDefineIIFENodes);
        }
      }
    }
  });

  Module.prototype.toCode = function(astCode, codegenOptions) {
    if (astCode == null) {
      astCode = this.AST_body;
    }
    if (codegenOptions == null) {
      codegenOptions = this.codegenOptions;
    }
    this.updateRequireLiteralASTs();
    return toCode(astCode, codegenOptions);
  };

  return Module;

})(TextResource);

module.exports = Module;

_.extend(module.exports.prototype, {
  l: l,
  _: _,
  _B: _B
});
