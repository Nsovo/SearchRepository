// Generated by CoffeeScript 1.8.0
var Build, BundleFile, UError, fs, isTrueOrFileInSpecs, l, mkdirp, pathRelative, upath, _, _B;

_ = (_B = require('uberscore'))._;

l = new _B.Logger('uRequire/BundleFile');

fs = require('fs');

Build = require('../process/Build');

mkdirp = require("mkdirp");

upath = require('../paths/upath');

UError = require('../utils/UError');

isTrueOrFileInSpecs = require('../config/isTrueOrFileInSpecs');

pathRelative = '../paths/pathRelative';


/*
  Represents any file in the bundle (that matched `bundle.filez`)
 */

BundleFile = (function() {

  /*
    @param bundle {Object} The Bundle where this BundleFile belongs
    @param filename {String} bundleRelative eg 'models/PersonModel.coffee'
   */
  var bof, _fn, _i, _len, _ref;

  function BundleFile(data) {
    _.extend(this, data);
    this.dstFilename = this.srcFilename;
  }

  BundleFile.prototype.refresh = function() {
    var statProps, stats;
    if (!this.srcExists) {
      throw new UError("BundleFile missing '" + this.srcFilepath + "'");
    } else {
      stats = _.pick(fs.statSync(this.srcFilepath), statProps = ['mtime', 'size']);
      if (!_.isEqual(stats, this.fileStats)) {
        this.fileStats = stats;
        this.hasChanged = true;
      } else {
        this.hasChanged = false;
        if (l.deb(90)) {
          l.debug("No changes in " + statProps + " of file '" + this.dstFilename + "' ");
        }
      }
    }
    return this.hasChanged;
  };

  BundleFile.prototype.reset = function() {
    delete this.fileStats;
    return delete this.hasErrors;
  };

  _ref = ['clean'];
  _fn = function(bof) {
    return Object.defineProperty(BundleFile.prototype, 'is' + _.capitalize(bof), {
      get: function() {
        var _ref1, _ref2;
        return isTrueOrFileInSpecs((_ref1 = this.bundle) != null ? (_ref2 = _ref1.build) != null ? _ref2[bof] : void 0 : void 0, this.dstFilename);
      }
    });
  };
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    bof = _ref[_i];
    _fn(bof);
  }

  BundleFile.prototype.dstDelete = function() {
    var err;
    l.verbose("Deleting file: " + this.dstFilepath);
    try {
      return fs.unlinkSync(this.dstFilepath);
    } catch (_error) {
      err = _error;
      return l.er("Cant delete destination file '" + this.dstFilepath + "'.");
    }
  };

  Object.defineProperties(BundleFile.prototype, {
    extname: {
      get: function() {
        return upath.extname(this.srcFilename);
      }
    },
    srcFilepath: {
      get: function() {
        var _ref1;
        return upath.join(((_ref1 = this.bundle) != null ? _ref1.path : void 0) || '', this.srcFilename);
      }
    },
    srcRealpath: {
      get: function() {
        return "" + (process.cwd()) + "/" + this.srcFilepath;
      }
    },
    srcExists: {
      get: function() {
        return fs.existsSync(this.srcFilepath);
      }
    },
    dstPath: {
      get: function() {
        var _ref1, _ref2;
        return ((_ref1 = this.bundle) != null ? (_ref2 = _ref1.build) != null ? _ref2.dstPath : void 0 : void 0) || '';
      }
    },
    dstFilepath: {
      get: function() {
        return upath.join(this.dstPath, this.dstFilename);
      }
    },
    dstRealpath: {
      get: function() {
        return "" + (process.cwd()) + "/" + this.dstFilepath;
      }
    },
    dstExists: {
      get: function() {
        if (this.dstFilepath) {
          return fs.existsSync(this.dstFilepath);
        }
      }
    },
    pathToRoot: {
      get: function() {
        return pathRelative(upath.dirname(this.path), "/", {
          assumeRoot: true
        });
      }
    },
    sourceMapInfo: {
      get: function() {
        return {
          file: upath.basename(this.dstFilepath),
          sourceRoot: upath.dirname(upath.relative(upath.dirname(this.dstFilepath), this.srcFilepath)),
          sources: [upath.basename(this.srcFilepath)],
          sourceMappingURL: "/*\n//@ sourceMappingURL=" + (upath.basename(this.dstFilepath)) + ".map\n*/"
        };
      }
    }
  });

  BundleFile.prototype.copy = function(srcFilename, dstFilename) {
    var _ref1, _ref2, _ref3;
    if (srcFilename == null) {
      srcFilename = this.srcFilename;
    }
    if (dstFilename == null) {
      dstFilename = this.srcFilename;
    }
    return BundleFile.copy(upath.join(((_ref1 = this.bundle) != null ? _ref1.path : void 0) || '', srcFilename), upath.join(((_ref2 = this.bundle) != null ? (_ref3 = _ref2.build) != null ? _ref3.dstPath : void 0 : void 0) || '', dstFilename));
  };

  BundleFile.copy = function(srcFile, dstFile, overwrite) {
    var BUF_LENGTH, buff, bytesRead, compStats, dstFileDirname, err, fdr, fdw, pos, srcStats;
    if (overwrite == null) {
      overwrite = 'DUMMY';
    }
    if (!fs.existsSync(srcFile)) {
      throw new UError("copy: source file missing '" + srcFile + "'");
    } else {
      srcStats = _.pick(fs.statSync(srcFile), ['atime', 'mtime', 'size']);
      if (fs.existsSync(dstFile)) {
        compStats = ['mtime', 'size'];
        if (_.isEqual(_.pick(srcStats, compStats), _.pick(fs.statSync(dstFile), compStats))) {
          if (l.deb(80)) {
            l.debug("NOT copying same: srcFile='" + srcFile + "', dstFile='" + dstFile + "'");
          }
          return false;
        }
      }
    }
    if (l.deb(40)) {
      l.debug("copy {src='" + srcFile + "', dst='" + dstFile + "'}");
    }
    try {
      BUF_LENGTH = 64 * 1024;
      buff = new Buffer(BUF_LENGTH);
      fdr = fs.openSync(srcFile, 'r');
      if (!fs.existsSync(dstFileDirname = upath.dirname(dstFile))) {
        l.verbose("copy: Creating directory " + dstFileDirname);
        mkdirp.sync(dstFileDirname);
      }
      fdw = fs.openSync(dstFile, 'w');
      bytesRead = 1;
      pos = 0;
      while (bytesRead > 0) {
        bytesRead = fs.readSync(fdr, buff, 0, BUF_LENGTH, pos);
        fs.writeSync(fdw, buff, 0, bytesRead);
        pos += bytesRead;
      }
      fs.closeSync(fdr);
      fs.closeSync(fdw);
      fs.utimesSync(dstFile, srcStats.atime, srcStats.mtime);
      return true;
    } catch (_error) {
      err = _error;
      throw new UError("copy: Error copying from '" + srcFile + "' to '" + dstFile + "'", {
        nested: err
      });
    }
  };

  BundleFile.requireUncached = function(name) {
    var searchCache;
    searchCache = function(name, callback) {
      var mod, run;
      mod = require.resolve(name);
      if (mod && ((mod = require.cache[mod]) !== void 0)) {
        return (run = function(mod) {
          mod.children.forEach(function(child) {
            return run(child);
          });
          return callback(mod);
        })(mod);
      }
    };
    searchCache(name, function(mod) {
      return delete require.cache[mod.id];
    });
    return require(name);
  };

  BundleFile.prototype.requireUncached = function(name) {
    if (name == null) {
      name = this.srcRealpath;
    }
    return BundleFile.requireUncached(name);
  };

  BundleFile.prototype.inspect = function() {
    var inspectText;
    inspectText = " " + this.constructor.name + " : '" + this.srcFilename + "' ";
    if (this.hasChanged) {
      inspectText += '(hasChanged)';
    }
    if (this.hasErrors) {
      inspectText += '(hasErrors)';
    }
    return inspectText;
  };

  return BundleFile;

})();

module.exports = BundleFile;

_.extend(module.exports.prototype, {
  l: l,
  _: _,
  _B: _B
});
