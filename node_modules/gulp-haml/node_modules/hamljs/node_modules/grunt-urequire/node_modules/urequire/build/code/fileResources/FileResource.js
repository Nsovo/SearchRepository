// Generated by CoffeeScript 1.8.0
var BundleFile, FileResource, ResourceConverterError, UError, fs, l, mkdirp, upath, _, _B,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = (_B = require('uberscore'))._;

l = new _B.Logger('uRequire/FileResource');

fs = require('fs');

mkdirp = require('mkdirp');

BundleFile = require('./BundleFile');

upath = require('../paths/upath');

UError = require('../utils/UError');

ResourceConverterError = require('../utils/ResourceConverterError');


/*
  Represents any bundlefile resource, whose source/content we dont read (but subclasses do).

  The `convert()` of the ResourceConverter should handle the file contents - for example fs.read it, require() it or spawn an external program.

  Paradoxically, a FileResource
    - can `read()` its source contents (assumed utf-8 text)
    - can `save()` its `converted` content (if any).

  Each time it `@refresh()`es, if super is changed (BundleFile's fileStats), it runs `runResourceConverters`:
      - calls `converter.convert()` and stores result as @converted
      - calls `converter.convFilename()` and stores result as @dstFilename
    otherwise it returns `@hasChanged = false`

  When `save()` is called (with no args) it outputs `@converted` to `@dstFilepath`.
 */

FileResource = (function(_super) {
  var readOptions, saveOptions;

  __extends(FileResource, _super);

  function FileResource() {
    return FileResource.__super__.constructor.apply(this, arguments);
  }


  /*
    @data converters {Array<ResourceConverter} (bundle.resources) that matched this filename & are used in turn to convert, each time we `refresh()`
   */


  /*
    Check if source (AS IS eg js, coffee, LESS etc) has changed
    and convert it passing throught all @converters
  
    @return true if there was a change (and convertions took place) and note as @hasChanged
            false otherwise
   */

  FileResource.prototype.refresh = function() {
    if (!FileResource.__super__.refresh.apply(this, arguments)) {
      return false;
    } else {
      if (this.constructor === FileResource) {
        return this.hasChanged = this.runResourceConverters(function(rc) {
          return !rc.isBeforeTemplate && !rc.isAfterTemplate;
        });
      } else {
        return true;
      }
    }
  };

  FileResource.prototype.reset = function() {
    FileResource.__super__.reset.apply(this, arguments);
    return delete this.converted;
  };

  FileResource.prototype.runResourceConverters = function(convFilter) {
    var err, oldDstFn, resConv, _i, _len, _ref, _ref1, _ref2;
    if (convFilter == null) {
      convFilter = function() {
        return true;
      };
    }
    this.hasErrors = false;
    _ref = this.converters;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      resConv = _ref[_i];
      if (!(convFilter(resConv) && (resConv.enabled === true))) {
        continue;
      }
      if (l.deb(40)) {
        l.deb(40, ("ResourceConverter '" + resConv.name + "' ") + ("for `" + ((_ref1 = this.constructor) != null ? _ref1.name : void 0) + "` '" + this.srcFilename + "' ") + (l.deb(70) ? " dstFn='" + this.dstFilename + "'" : ''));
      }
      try {
        if (_.isFunction(resConv.convert)) {
          if (l.deb(90)) {
            l.deb("`resourceConverter.convert()` for '" + resConv.name + "'");
          }
          this.converted = resConv.convert(this);
        }
        if (_.isFunction(resConv.convFilename)) {
          if (l.deb(60)) {
            l.deb("`resourceConverter.convFilename()` for '" + resConv.name + "'...");
          }
          oldDstFn = this.dstFilename;
          this.dstFilename = resConv.convFilename(this.dstFilename, this.srcFilename, this);
          if (l.deb(60)) {
            if (this.dstFilename !== oldDstFn) {
              l.deb("...@dstFilename changed from '" + oldDstFn + "' to '" + this.dstFilename + "'");
            } else {
              l.deb(80, "@dstFilename remained '" + oldDstFn + "'");
            }
          }
        }
        this.hasChanged = true;
      } catch (_error) {
        err = _error;
        this.hasErrors = true;
        throw new ResourceConverterError("Error converting " + ((_ref2 = this.constructor) != null ? _ref2.name : void 0) + " '" + this.srcFilename + "' with ResourceConverter '" + (resConv != null ? resConv.name : void 0) + "':", {
          nested: err
        });
      }
      if (resConv.isTerminal) {
        break;
      }
    }
    return this.hasChanged;
  };

  readOptions = 'utf-8';

  FileResource.prototype.read = function(filename, options) {
    var err, _ref;
    if (filename == null) {
      filename = this.srcFilename;
    }
    if (options == null) {
      options = readOptions;
    }
    if (options !== readOptions) {
      _.defaults(options, readOptions);
    }
    filename = upath.join(((_ref = this.bundle) != null ? _ref.path : void 0) || '', filename);
    try {
      return fs.readFileSync(filename, options);
    } catch (_error) {
      err = _error;
      this.hasErrors = true;
      this.bundle.handleError(new UError("Error reading file '" + filename + "'", {
        nested: err
      }));
      return void 0;
    }
  };

  FileResource.prototype.save = function(filename, content, options) {
    if (filename == null) {
      filename = this.dstFilename;
    }
    if (content == null) {
      content = this.converted;
    }
    return this.constructor.save.call(this, upath.join(this.dstPath, filename), content, options);
  };

  saveOptions = 'utf-8';

  FileResource.save = function(filename, content, options) {
    var err, fileDirname, uerr;
    if (options == null) {
      options = saveOptions;
    }
    if (options !== saveOptions) {
      _.defaults(options, saveOptions);
    }
    if (l.deb(95)) {
      l.debug("Saving file '" + filename + "'...");
    }
    if (!filename) {
      this.bundle.handleError(new UError("Error saving - no filename"));
    }
    if (!content) {
      this.bundle.handleError(new UError("Error saving - no content"));
    }
    try {
      if (!fs.existsSync(fileDirname = upath.dirname(filename))) {
        l.verbose("save: Creating directory '" + fileDirname + "'");
        mkdirp.sync(fileDirname);
      }
      fs.writeFileSync(filename, content, options);
      l.verbose("Saved file '" + filename + "'");
      return true;
    } catch (_error) {
      err = _error;
      l.er(uerr = "Can't save '" + filename + "'", err);
      return this.bundle.handleError(new UError(uerr, {
        nested: err
      }));
    }
  };

  return FileResource;

})(BundleFile);

module.exports = FileResource;

_.extend(module.exports.prototype, {
  l: l,
  _: _,
  _B: _B
});
