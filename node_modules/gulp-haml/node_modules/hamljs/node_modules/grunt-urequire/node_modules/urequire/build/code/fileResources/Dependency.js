// Generated by CoffeeScript 1.8.0
var Dependency, MasterDefaultsConfig, UError, isFileInSpecs, l, minimatch, pathRelative, untrust, upath, util, _, _B,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = (_B = require('uberscore'))._;

l = new _B.Logger('uRequire/Dependency');

_.mixin((require('underscore.string')).exports());

MasterDefaultsConfig = require('../config/MasterDefaultsConfig');

upath = require('./../paths/upath');

pathRelative = require('./../paths/pathRelative');

isFileInSpecs = require('../config/isFileInSpecs');

UError = require('../utils/UError');

minimatch = require('minimatch');

util = require('util');

untrust = function(str) {
  str = new String(str + '');
  str.untrusted = true;
  str.inspect = function() {
    return "'" + this + "' (untrusted Dependency)";
  };
  return str;
};

Dependency = (function() {

  /*
    @param {String} depString The original dependency, as passed i.e 'uberscore' or '../mylibs/dep'
  
    @param {Module} module The module that has this dependency (optional).
        Used to calculate relative paths via its `.path` property.
        Can be a {} optionally containing a:
         - .path, as String, i.e the bundleRelative filename eg 'somePath/ModuleName'
         - .bundle or any {} with {dstFilenames: Array<String>}
          The dstFilenames (bundleRelative) in the bundle are used to
          calculate whether './../myDep' isFound, which in turn is used by isLocal and others etc.
   */
  var TYPES, isSameJSFile, type, _fn, _i, _len;

  Dependency.defaults = {
    untrusted: false
  };

  function Dependency(depString, module, defaults) {
    this.module = module;
    if (defaults == null) {
      defaults = Dependency.defaults;
    }
    if (defaults !== Dependency.defaults) {
      _.defaults(this, defaults);
    }
    this.AST_requireLiterals || (this.AST_requireLiterals = []);
    this.depString = depString;
  }

  Dependency.prototype.clone = function() {
    return new Dependency(this.depString, this.module, {
      AST_requireLiterals: this.AST_requireLiterals,
      untrusted: this.untrusted
    });
  };

  Object.defineProperties(Dependency.prototype, {
    depString: {
      get: function() {
        if (this.untrusted) {
          return untrust(this._depString);
        } else {
          return this._depString;
        }
      },
      set: function(depString) {
        var dp, indexOfSep;
        if (depString == null) {
          depString = '';
        }
        this._depString = depString;
        dp = depString.replace(/\\/g, '/');
        indexOfSep = dp.indexOf('!');
        if (indexOfSep > 0) {
          if (!this.plugin) {
            this.plugin = new Dependency(dp.slice(0, +(indexOfSep - 1) + 1 || 9e9), this);
          } else {
            this.plugin.depString = dp.slice(0, +(indexOfSep - 1) + 1 || 9e9);
          }
        } else {
          delete this.plugin;
        }
        this.originalResourceName = indexOfSep >= 0 ? dp.slice(indexOfSep + 1, +(dp.length - 1) + 1 || 9e9) : dp;
        this.resourceName = upath.normalizeSafe(this.originalResourceName);
        if (_.last(this.resourceName) === '|') {
          this.resourceName = this.resourceName.slice(0, +(this.resourceName.length - 2) + 1 || 9e9);
          this.isPartial = true;
        }
        if (_.last(this.resourceName) === '/') {
          this.resourceName = this.resourceName.slice(0, +(this.resourceName.length - 2) + 1 || 9e9);
        }
        if (upath.extname(this.resourceName)) {
          this.extname = upath.extname(this.resourceName);
          this.resourceName = upath.trimExt(this.resourceName);
        }
        return this.updateAST();
      }
    }
  });

  Dependency.prototype.updateAST = function() {
    var depLiteral, name, _i, _len, _ref, _results;
    _ref = this.AST_requireLiterals || [];
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      depLiteral = _ref[_i];
      if (depLiteral.value !== (name = this.name())) {
        l.debug(80, "Replacing AST literal '" + depLiteral.value + "' with '" + name + "'");
        _results.push(depLiteral.value = name);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  TYPES = ['notFoundInBundle', 'external', 'untrusted', 'system', 'bundle', 'nodeLocal'];

  _fn = function(type) {
    return Object.defineProperty(Dependency.prototype, 'is' + _.capitalize(type), {
      get: function() {
        return this.type === type;
      }
    });
  };
  for (_i = 0, _len = TYPES.length; _i < _len; _i++) {
    type = TYPES[_i];
    _fn(type);
  }

  Object.defineProperties(Dependency.prototype, {
    isLocal: {
      get: function() {
        var _ref;
        return (_ref = this.type) === 'local' || _ref === 'nodeLocal';
      }
    },
    pluginName: {
      get: function() {
        if (this.plugin) {
          return this.plugin.name();
        } else {
          return '';
        }
      }
    },
    type: {
      get: function() {
        var _ref;
        if (this.untrusted) {
          return 'untrusted';
        } else {
          if ((_ref = this.depString) === 'require' || _ref === 'exports' || _ref === 'module') {
            return 'system';
          } else {
            if (this.isWebRootMap) {
              return 'webRootMap';
            } else {
              if (this.isNode) {
                if (this._isInLocals) {
                  return 'nodeLocal';
                } else {
                  return 'node';
                }
              } else {
                if (this.isFound || this.isFoundAsIndex) {
                  return 'bundle';
                } else {
                  if (!this._isBundleBoundary) {
                    return 'external';
                  } else {
                    if ((this.resourceName.indexOf('/') < 0) || this._isInLocals) {
                      return 'local';
                    } else {
                      return 'notFoundInBundle';
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    _isInLocals: {
      get: function() {
        var _ref, _ref1, _ref2;
        return (((_ref = this.module) != null ? (_ref1 = _ref.bundle) != null ? (_ref2 = _ref1.dependencies) != null ? _ref2.locals : void 0 : void 0 : void 0) || MasterDefaultsConfig.bundle.dependencies.locals)[this.resourceName.split('/')[0]];
      }
    },
    isNode: {
      get: function() {
        var _ref, _ref1, _ref2, _ref3;
        return (((_ref = this.plugin) != null ? typeof _ref.name === "function" ? _ref.name() : void 0 : void 0) === 'node') || isFileInSpecs(this.name({
          plugin: false,
          relative: 'bundle'
        }), ((_ref1 = this.module) != null ? (_ref2 = _ref1.bundle) != null ? (_ref3 = _ref2.dependencies) != null ? _ref3.node : void 0 : void 0 : void 0) || MasterDefaultsConfig.bundle.dependencies.node);
      }
    },
    isFound: {
      get: function() {
        var _ref, _ref1, _ref2;
        if (_.isArray((_ref = this.module) != null ? (_ref1 = _ref.bundle) != null ? _ref1.dstFilenames : void 0 : void 0)) {
          return _ref2 = upath.defaultExt(this._bundleRelative, '.js'), __indexOf.call(this.module.bundle.dstFilenames, _ref2) >= 0;
        }
      }
    },
    isFoundAsIndex: {
      get: function() {
        var _ref, _ref1, _ref2;
        if (_.isArray((_ref = this.module) != null ? (_ref1 = _ref.bundle) != null ? _ref1.dstFilenames : void 0 : void 0)) {
          return _ref2 = upath.defaultExt(this._bundleRelative + '/index', '.js'), __indexOf.call(this.module.bundle.dstFilenames, _ref2) >= 0;
        }
      }
    },
    isWebRootMap: {
      get: function() {
        return this.resourceName[0] === '/';
      }
    },
    isRelative: {
      get: function() {
        return this.resourceName[0] === '.';
      }
    },
    _bundleRelative: {
      get: function() {
        var _ref;
        if (this.untrusted) {
          return this.depString;
        } else {
          if (this.isRelative) {
            return upath.join(upath.dirname(((_ref = this.module) != null ? _ref.path : void 0) || '.'), this.resourceName);
          } else {
            return upath.normalizeSafe(this.resourceName);
          }
        }
      }
    },
    _fileRelative: {
      get: function() {
        var _ref, _ref1;
        if (this.untrusted) {
          return this._depString;
        } else {
          if (((_ref = this.module) != null ? _ref.path : void 0) && (this.isFound || this.isFoundAsIndex)) {
            return pathRelative(upath.dirname(((_ref1 = this.module) != null ? _ref1.path : void 0) || '__root__'), this._bundleRelative, {
              dot4Current: true,
              assumeRoot: true
            });
          } else {
            return upath.normalizeSafe(this.resourceName);
          }
        }
      }
    },
    _isBundleBoundary: {
      get: function() {
        if (this.untrusted || this.isWebRootMap) {
          return false;
        } else {
          return !!this.pathToRoot;
        }
      }
    },
    pathToRoot: {
      get: function() {
        var _ref;
        return pathRelative("" + ((_ref = this.module) != null ? _ref.path : void 0) + "/../../" + this.resourceName, ".", {
          assumeRoot: true
        });
      }
    },
    modulePathToRoot: {
      get: function() {
        var _ref;
        return pathRelative(upath.dirname(((_ref = this.module) != null ? _ref.path : void 0) || "__root__"), "/", {
          assumeRoot: true
        });
      }
    }
  });

  Dependency.prototype.name = function(options) {
    if (options == null) {
      options = {};
    }
    if (this.untrusted) {
      return this.depString;
    } else {
      if (options.ext == null) {
        options.ext = false;
      }
      if (options.plugin == null) {
        options.plugin = true;
      }
      if (options.relative == null) {
        options.relative = 'file';
      }
      if (options.quote == null) {
        options.quote = false;
      }
      return (options.quote ? "'" : '') + (options.plugin && this.plugin && !this.isNode ? this.plugin.name() + '!' : '') + (options.relative === 'bundle' ? this._bundleRelative : this._fileRelative) + (!this.isFound && this.isFoundAsIndex ? '/index' : '') + (options.ext === false || !this.extname ? '' : this.extname) + (options.quote ? "'" : '');
    }
  };

  Dependency.prototype.toString = function() {
    return this.depString;
  };

  Dependency.prototype.inspect = function() {
    if (this.untrusted) {
      return this.depString;
    } else {
      return "'" + (this.name()) + "'";
    }
  };


  /*
  Compare this Dependency instance with another, either Dependency or a string representation of another dep.
  
  It caters for different representations of
    * bundleRelative / fileRelative
    * having `.js` extension or not
    * having plugin or not
  by comparing the bundleRelative paths with (default) .js extension
  
  @param dep {Dependency | String | .toString} The depedency to compare with this - returns true if
  @todo: use @isMatch dep, {some:options}
   */

  Dependency.prototype.isEqual = function(dep) {
    var _ref, _ref1;
    if (dep === this) {
      return true;
    }
    if (!dep || this.untrusted) {
      return false;
    }
    if (!(dep instanceof Dependency)) {
      dep = new Dependency(dep, this.module);
    }
    if ((((_ref = this.module) != null ? _ref.bundle : void 0) != null) !== (((_ref1 = dep.module) != null ? _ref1.bundle : void 0) != null)) {
      return false;
    }
    return isSameJSFile(this.name({
      relative: 'bundle',
      ext: true
    }), dep.name({
      relative: 'bundle',
      ext: true
    }));
  };

  isSameJSFile = function(a, b) {
    return upath.defaultExt(a, '.js') === upath.defaultExt(b, '.js');
  };


  /*
  Check if this Dependency instance matches with a:
  
   * Another Dependency instance that has to *match* with this dep
      * All its data like @plugin.name() or @resourceName, ext etc have to match
  
      * Its resourceName can be a partial or minimatch search it self. @todo: & plugin
  
    * A string representation with either:
  
      * a resourceName like `src/models/Person`, possibly prefixed with an AMD-style pluginName like 'plugins/spy!src/models/Person'`
  
      * a *partial* `resourceName`, denoted by | at the end, eg `'myplugin/spy|!src|'`
  
      * a `minimatch` comparison of @plugin.name() & @resourceName comparison # @todo look below
  
    * A RegExp, again matching both @plugin.name() & @resourceName on its own
  
  * ???? A Function called with depName, dep ???
  
  It caters for different representations of
    * bundleRelative / fileRelative
    * having `.js` extension or not
    * having plugin or not
  by comparing the bundleRelative paths with (default) .js extension
  
  @param matchDep {Dependency | String | RegExp | Function | {toString: function} The depedency to compare with this
  
  @return true if a match, false otherwise
  
   * @todo: write more specs & doc it better
   * @todo: convert to agreement / _B.Blender
   * @todo: return  matched part if its a partial match (needs tweak for minimatch / impossible!)
   */

  Dependency.prototype.isMatch = function(matchDep, options) {
    var err, matchDepName, thisName, _ref, _ref1;
    if (l.deb(105)) {
      l.deb("isMatch: options =", options, "\nmatchDep =", matchDep, "\n@ =", this);
    }
    if (!matchDep || this.untrusted) {
      return false;
    }
    if (_.isRegExp(matchDep)) {
      return matchDep.test(this.name(options));
    }
    if (_.isString(matchDep)) {
      matchDep = new Dependency(matchDep, this.module);
    }
    if (!(matchDep instanceof Dependency)) {
      l.er(err = "Dependency.isMatch: wrong dependency type '" + matchDep + "' should be String|RegExp|Dependency.");
      throw new UError(err);
    } else {
      if ((((_ref = this.module) != null ? _ref.bundle : void 0) != null) !== (((_ref1 = matchDep.module) != null ? _ref1.bundle : void 0) != null)) {
        if (l.deb(120)) {
          l.deb("isMatch: false cause of module.bundle");
        }
        return false;
      }
      if (this.plugin && !this.plugin.isMatch(matchDep.plugin, options)) {
        if (l.deb(120)) {
          l.deb("isMatch: false cause of @plugin.isMatch");
        }
        return false;
      }
      matchDepName = matchDep.resourceName;
      thisName = this.name({
        plugin: false,
        relative: options.relative
      });
      if (matchDep.isPartial) {
        if (!_.startsWith(thisName, matchDepName)) {
          if (l.deb(120)) {
            l.deb("isMatch: false cause isPartial _.startsWith '" + thisName + "', '" + matchDepName + "'");
          }
          return false;
        }
      } else {
        matchDepName = upath.defaultExt(matchDepName, '.js');
        thisName = upath.defaultExt(thisName, '.js');
        if (!minimatch(matchDepName, thisName)) {
          if (l.deb(120)) {
            l.deb("isMatch: false cause of false minimatch('" + matchDepName + "', '" + thisName + "')");
          }
          return false;
        }
      }
      if (l.deb(110)) {
        l.deb("isMatch: true");
      }
      return true;
    }
  };

  Dependency.prototype.update = function(newDep, matchDep, options) {
    var newDepPaths, newDepString, noPluginOptions, partialPath;
    if (l.deb(80)) {
      l.deb("update: options =", options, "\n@ =", this, "\nnewDep =", newDep, "\nmatchDep =", matchDep);
    }
    newDepPaths = [];
    if ((options.relative === 'bundle') && newDep.isRelative) {
      l.deb(110, "update: translate {relative:'bundle'} path to {relative:'file'}. Adding @modulePathToRoot = ", this.modulePathToRoot);
      newDepPaths.push(this.modulePathToRoot);
    }
    newDepPaths.push(newDep.name({
      relative: 'file',
      plugin: false,
      ext: true
    }));
    (noPluginOptions = _.clone(options)).plugin = false;
    if (matchDep && matchDep.isPartial) {
      partialPath = this.name(noPluginOptions).slice(matchDep.name({
        plugin: false
      }).length + 1);
      l.deb(110, "update: adding partialPath =", partialPath);
      newDepPaths.push(partialPath);
    }
    newDepString = upath.join.apply(null, newDepPaths);
    if (newDep.plugin) {
      if (this.plugin) {
        newDepString = (this.plugin.update(newDep.plugin, matchDep != null ? matchDep.plugin : void 0, options)) + '!' + newDepString;
      } else {
        newDepString = newDep.pluginName + '!' + newDepString;
      }
    }
    if (l.deb(90)) {
      l.deb("Dependency.update replacing @depString '" + this.depString + "' with '" + newDepString + "'.");
    }
    return this.depString = newDepString;
  };

  return Dependency;

})();

module.exports = Dependency;

_.extend(module.exports.prototype, {
  l: l,
  _: _,
  _B: _B
});
