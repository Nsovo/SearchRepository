Dust is a JavaScript templating engine designed to provide a clean separation between presentation and logic without sacrificing ease of use. It is particularly well-suited for asynchronous and streaming applications.

### Syntax

Dust templates use two types of tags: _keys_ and _sections_. Keys reference fields within the current view context. You can think of them as placeholders that allow the context to insert data into the template. Sections accept template blocks that may be enumerated, filtered or transformed in various ways.

### Keys

To reference a key from the view context within the template, enclose the key in curly braces. For example, given the template below:

    Hello {name}!

And the following view context:

    { name: "Fred" }

The resulting output would be:

    Hello Fred!

If the _name_ key cannot be found in the view, Dust outputs an empty string:

    Hello !

Generally, Dust casts whatever values it finds to strings. If Dust encounters a handler function it calls the function, passing in the current state of the template.

#### Filters

By default, the content of all key tags is HTML escaped, so assuming the _name_ key above resolves to a dangerous script tag:

    <script>alert('I am evil!')</script>

This would be rendered as:

    &lt;script&gt;alert('I am evil!')&lt;/script&gt;

To disable auto-escaping, append a pipe character '|' and an 's' to the end of the tag identifier, like so:

    Hello {name|s}

There are several other built-in filters: `h` forces HTML escaping, `j` escapes JavaScript strings, `u` proxies to JavaScript's built-in `encodeURI`, and `uc` proxies to JavaScript's `encodeURIComponent`. Filters can also be chained together like so:

    Hello {name|s|h|u}

When chained in this manner, filters are applied from left to right. Filters do not accept arguments; if you need more sophisticated behavior use a section tag instead.

### Sections

Keys are fine for simple lookups, but suppose the view context contains a _friends_ field which resolves to an array of objects containing _name_ and _age_ fields. This is where section tags are useful.

    {#friends}
      {name}, {age}{~n}
    {/friends}

Here, the section begins with `{#friends}` and ends with `{/friends}`. Dust's default behavior is to enumerate over the array, passing each object in the array to the block. With a the following view context:

    {
      friends: [
        { name: "Moe", age: 37 },
        { name: "Larry", age: 39 },
        { name: "Curly", age: 35 }
      ]
    }

The output is as one might expect:

    Moe, 37
    Larry, 39
    Curly, 35

When _friends_ resolves to a value or object instead of an array, Dust sets the current context to the value and renders the block one time. If _friends_ resolves to a custom handler function, the function is given control over the section's behavior.

Dust outputs nothing if the friends key is empty or nonexistent. Let's change that by inserting an `{:else}` tag, which tells Dust to render an alternate template block when a section key resolves to a falsy value:

    {#friends}
      {name}, {age}{~n}
    {:else}
      You have no friends!
    {/friends}

Now when the friends key is empty or nonexistent we get the following:

    You have no friends!

Internally, Dust builds a stack of contexts as templates delve deeper into nested sections. If a key is not found within the current context, Dust looks for the key within the parent context, and its parent, and so on.

Self-closing section tags are allowed, so the template code below is permissible (although in 