var debug = require('debug')('remotes:github');
var utils = require('component-consoler');
var Remote = require('../remote')

var GITHUB_USERNAME = process.env.GITHUB_USERNAME
var GITHUB_PASSWORD = process.env.GITHUB_PASSWORD

var API_COUNTER = 0; // keeps track of API requests and output via debug at process exit

module.exports = GitHub

Remote.extend(GitHub)

function GitHub(options) {
  if (!(this instanceof GitHub))
    return new GitHub(options)

  options = Object.create(options || {});

  // set the github API auth via environment
  // otherwise, use netrc or something.
  if (!options.auth && GITHUB_USERNAME && GITHUB_PASSWORD)
    options.auth = GITHUB_USERNAME + ':' + GITHUB_PASSWORD

  Remote.call(this, options)
}

GitHub.prototype.name = 'github'

/**
 * api.github.com can't do redirects, so we need to do it by hand
 *
 * @param {String} repo
 * @return {String} nenamed repo
 * @api public
 */


GitHub.prototype._checkRedirect = function* (repo) {
  debug('try to resolve renamed repo');
  var baseUrl = 'https://github.com/';
  var uri = baseUrl + repo;
  var res = yield* this.request(uri, {string: true, method: 'HEAD', redirects: 0});
  var newLocation = res.headers.location;
  if (newLocation) {
    var newRepo = newLocation.substr(baseUrl.length);
    utils.log('outdated name of a dependency','please update: "' + repo + '" -> "' + newRepo + '"');
    return newRepo;
  }
  return null;
}

GitHub.prototype.getHash =function* (repo, ref) {
  var uri = 'https://api.github.com/repos/' + repo + '/commits?sha=' + ref;
  debug('GET "%s"', uri);
  API_COUNTER++;
  var hash = null;
  var res = yield* this.request(uri, true);
  if (res.statusCode === 404) {
    debug('could not fetch hash for ' + repo, ref);
  } else {
    hash = res.body[0].sha;
  }
  return hash;
};

/**
 * @param {String} repo
 * @return {Array} references
 * @api public
 */

GitHub.prototype._versions = function* (repo) {
  var uri = 'https://api.github.com/repos/' + repo + '/tags';
  debug('GET "%s"', uri);
  API_COUNTER++;
  var res = yield* this.request(uri, true);
  // this shouldn't happen as the remote should be resolved first
  // if it does happen, it could be that the repo was moved and .json() redirected.
  // we need a good UI to fix this
  if (res.statusCode === 404) {
    // fallback: check if the repo was renamed
    var renamed = yield* this._checkRedirect(repo);
    if (renamed) {
      return yield* this._versions(renamed);
    }
  }
  if (res.statusCode === 404) {
    var err = new Error('failed to get ' + repo + '\'s tags. please check that this repository still exists!');
    err.res = res;
    err.remote = 'github';
    throw err;
  }
  if (res.statusCode === 403) return errorRateLimitExceeded(res);
  if (res.statusCode === 401) return errorBadCredentials(res);
  if (res.statusCode !== 200) {
    var err = new Error('failed to get ' + repo + '\'s tags');
    err.res = res;
    err.remote = 'github';
    throw err;
  }
  checkRateLimitRemaining(res);

  return res.body.map(name);
}

function name(x) {
  return x.name
}

/**
 * Get a component and references's component.json.
 * Since GitHub has raw.github.com as well as raw.githubusercontent.com,
 * we try both URLs, and ignore any errors that might be returned.
 * This includes 404s as some repos are available on one endpoint,
 * but not the other.
 *
 * @param {String} repo
 * @param {String} reference
 * @return {Object} component.json
 * @api public
 */

GitHub.prototype._json = function* (repo, ref) {
  var retries = this.retries;
  var uris;
  var uri;
  var res;
  for (var i = 0; i <= retries; i++) {
    uris = this.file(repo, ref, 'component.json');
    for (var j = 0; j < uris.length; j++) {
      uri = uris[j];
      debug('GET "%s"', uri);
      try {
        res = yield* this.request(uri, true);
      } catch (err) {
        debug('error when GETing "%s": "%s', uri, err.message);
        continue;
      }
      if (res.statusCode !== 200) continue;
      return res.body;
    }
  }
}

/**
 *
 * @param {String} repo
 * @param {String} ref
 * @return {Array} objects
 *